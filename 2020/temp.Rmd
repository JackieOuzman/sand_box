---
title: "Shiny selectInput based on another selectInput"
runtime: shiny
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, error=TRUE)

```

```{r create_table_of_choices, eval=TRUE}

# table of choices for the selectInput controls
# note there's a duplicate item 'Pear'

  x <- c("Fruit","Animal","Animal","Fruit","Fruit","Animal","Animal","Fruit")
  y <- c("Pear","Dog","Cat","Apple","Banana","Monkey","Giraffe","Pear")

# bind x and y into a dataframe with two columns, using cbind() (column bind), and as.data.frame so we can apply unique.
  choices_table <- as.data.frame(cbind(x,y))
  colnames(choices_table) <- c("category","items")

# look at the table of choices
#   choices_table
#   choices_table$category

```

```{r selectInputs, eval=TRUE, error=TRUE}

# create and display the FIRST selectInput control

selectInput(inputId="choose_category",
            label="Select category",
            choices=unique(choices_table$category),
            selected="Animal")

# display the second selectInput control - note that we can
#  define the output further down in the R script, R will find the output

uiOutput("cat_choice")

#display the table with the user's choices from the selectInputs
tableOutput("tb_chosen")

output$tb_chosen <- renderTable(subset(choices_table,
 choices_table$category==input$choose_category & 
 choices_table$items==input$choose_item), rownames = TRUE)

# The SECOND selectInput control
# create an output variable based on the first control
# wrap the variable in a reactive function renderUI() 
#  so that we can capture the dynamic output from
#  the first selectInput.
# We've used 'unique' when subsetting the choices
#  because we have duplicate items

output$cat_choice <- renderUI({
  selectInput(inputId="choose_item",
            label="Select item",
            choices=unique(choices_table 
            [choices_table$category==input$choose_category,"items"]))
})

```
