---
title: "Sandbox 2020"
author: "Jackie Ouzman"
#date: "Last run: `r Sys.Date()`"
date: "Last run: `r format(Sys.time(), '%d %B %Y')`"
output: html_document
 
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### 2020 Sandbox / Ripper

This R Markdown document, will be used collate development ideas for the sanbox tool.
The aim of the app is to help farmers make profitable management decisions, when dealing with sandy soils.

The idea is that I will have chucks of code and widgets that can be used in a R shiny app.



```{r import lib, include=FALSE}
#install.packages("dplyr")

library(dplyr)
library(tidyverse)
library(shiny)
library(DT)
```

## Bring in the template data

This will be replaced with data supplied by Rick.
This will conatin a number of fields which will help with filtering functions.
The template data will guide the user with values, but they will be able to override these will there own data.

```{r import_data, echo=FALSE}
df <- read_csv(file = "input_sheet_template.csv")

#path <- file.path("C:","Users","ouz001","working_from_home","ripper","2020")
#df <- read_csv(paste0(path, "/" ,"input_sheet_template.csv"))
head(df, 3)
```

# Add a widget for the user to select
## This will filter the data frame to retain what grouping was selected.
There are a few ways you could go about this.
couple of options are from:

https://excelquick.com/r-shiny/selectinput-dependent-on-another-input/

https://stackoverflow.com/questions/38007070/creating-depandant-select-input-in-shiny-r 


I have explore a few examples and retained them in this documnet
but the code that is running is what I am after.



```{r select_grouping, eval=FALSE, include=FALSE}

#All we are doing here is selecting a grouping. 
#Then it returns a df that is filtered for the selection.


# df <- df %>% 
#   filter(grouping == "mixing")
# head(df, 10)

 radioButtons("grouping", label = h3("Grouping"), 
     choices = list("Mixing" = "mixing", "Fracturing" = "fracturing", "Fix pH" = "fix_pH"),
     selected = "mixing")
    
 
 renderDataTable({
 df_grouping <- df %>% 
    filter(grouping == input$grouping)
 })


```



```{r select_nested_grouping, eval=FALSE, include=FALSE}

# The method used here is from:
# https://excelquick.com/r-shiny/selectinput-dependent-on-another-input/
# 2 metods listed here
# This is method 1 - not used at this stage

selectInput(inputId="choose_grouping",
            label="Select grouping",
            choices=unique(df$grouping),
            selected="mixing")

# display the second selectInput control - note that we can
# define the output further down in the R script, R will find the output

uiOutput("cat_choice")

#display the table with the user's choices from the selectInputs
tableOutput("tb_chosen")

output$tb_chosen <- renderTable(
  subset(df,
 df$grouping==input$choose_grouping & 
 df$intervenion==input$choose_intervenion), 
 rownames = TRUE)

# The SECOND selectInput control
# create an output variable based on the first control
# wrap the variable in a reactive function renderUI() 
#  so that we can capture the dynamic output from
#  the first selectInput.
# We've used 'unique' when subsetting the choices
#  because we have duplicate intervenion

output$cat_choice <- renderUI({
  selectInput(inputId="choose_intervenion",
            label="Select intervenion",
            choices=unique(df 
            [df$grouping==input$choose_grouping,"intervenion"]))
})

```



```{r method2, eval=FALSE, include=FALSE}

# The method used here is from:
# https://excelquick.com/r-shiny/selectinput-dependent-on-another-input/
# 2 metods listed here
# This is method 2 - not used at this stage

# create both selectInput selection control
# in this example we also show how to add the controls
#  into a formatted input panel

# start of inputPanel
inputPanel(
 
 selectInput(inputId="choose_grouping2",
            label="Select grouping2",
            choices=unique(df$grouping),
            selected=unique(df$grouping)[1]),

 selectInput(inputId="choose_intervenion2",
            label="Select intervenion2",
            choices=unique(df$intervenion),
            selected=unique(df$intervenion)[1])
# end of inputPanel
          )

tableOutput("tb_chosen2")

output$tb_chosen2 <- renderTable(subset(df,
                                       df$grouping==input$choose_grouping2 &                                                           df$intervenion==input$choose_intervenion2), 
                                       rownames=TRUE)

# observe function which updates the second selectInput when the 
#  first selectInput is changed
observe({
  updateSelectInput(session,
                    inputId = "choose_intervenion2",
                    choices = unique(df[df$grouping == input$choose_grouping2, "intervenion"]))
        })
```

This is the one I will use!



```{r method3_site, echo=FALSE}


inputPanel(uiOutput("data1"),   ## uiOutput - gets the UI from the server
      uiOutput("data2"),
      uiOutput("data3"))

tableOutput("tb_chosen3")

  
 output$data1 <- renderUI({
    selectInput("data1", "Select grouping",      
                choices = c(df$grouping))
  })
  ## input dependant on the choices in `data1`
   output$data2 <- renderUI({
    selectInput("data2", "select intervenion",   
                choices = c(df$intervenion[df$grouping == input$data1]))
   })
  ## input dependant on the choices in `data2`
  output$data3 <- renderUI({
    selectInput("data3", "select site",          
                choices = c(df$site[df$intervenion == input$data2]))
  })

output$tb_chosen3 <- renderTable(subset(df,
                                       df$grouping==input$data1 &                                                                      df$intervenion==input$data2 &
                                       df$site==input$data3
                                       ), 
                                       rownames=TRUE)

 

```

##  Create a record of what was selected by making a df
This df can be used in a reactive enviorment and can be feed into function
or even as inputs.

```{r df_record_selection, echo=FALSE}
tableOutput("df_selection")

df_selection <- reactive({
   df %>% 
   filter(grouping == input$data1&
          intervenion==input$data2 &
           site==input$data3  ) %>% 
   select(grouping, intervenion, site ) %>% 
    slice(1L)
   
 })

 output$df_selection <- renderTable(df_selection())

```

##  Creat a record of what was selected by making a df
This df can be used in a reactive enviorment and can be feed into function
or even as inputs.

Ahh this is not working what we want is a min value for the yield for the data selected
and a max value (this will be the range to set with the slider input)

Not even sure thats what you want because you might have times when you want the yield to be higher or lower

Maybe I just want a text box?

```{r min_yld_max_yld, eval=FALSE, include=FALSE}
tableOutput("df_minYld")

df_minYld <- reactive({
   df %>% 
   filter(grouping == input$data1&
          intervenion==input$data2 &
           site==input$data3  ) %>% 
   select(grouping, intervenion, site, yield_t_ha ) %>% 
   slice_min(yield_t_ha, n = 1)
   
 })
output$df_minYld <- renderTable(df_minYld())

```
